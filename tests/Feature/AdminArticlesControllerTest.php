<?php

namespace Tests\Feature;

use App\Models\Article;
use App\Models\UserGroup;
use App\Services\Repositories\UserGroupRepository;
use App\Services\UserGroupsService;
use Faker\Factory;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Http\Response;
use Illuminate\Support\Str;
use Tests\TestCase;
use App\Models\User;
use Mockery;

/**
 * Проверка работы Admin\ArticlesController
 *
 * Class AdminArticlesControllerTest
 * @package Tests\Feature
 */
class AdminArticlesControllerTest extends TestCase
{
    //use WithoutMiddleware;

    use DatabaseTransactions;
    use WithFaker;

    private $userGroupsService;

    public function __construct($name = null, array $data = array(), $dataName = '')
    {
        parent::__construct($name, $data, $dataName);
        $this->createApplication();
        $this->userGroupsService = new UserGroupsService(new UserGroupRepository());
    }

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

    }

    /**
     * Проверка доступа к просмотру всех статей
     *
     * @dataProvider userDataProvider
     * @param User $user
     * @return void
     */
    public function testAccessToIndexAction(User $user)
    {
        $this->actingAs($user);
        $response = $this->get(route('articles.index'));
        if ($user->can('hasAdminAccess')) {
            $response->assertStatus(Response::HTTP_OK);
            $response->assertViewHas('articles');
        } else {
            $response->assertStatus(Response::HTTP_FOUND);
            $response->assertRedirect('/');
        }
    }

    /**
     * Проверка доступа на получение данных
     * для формы редактирования статьи
     *
     * @dataProvider userDataProvider
     * @param User $user
     * @return void
     */
    public function testAccessToEditAction(User $user)
    {
        $article = factory(Article::class)->create();
        $this->actingAs($user);
        $response = $this->get(route('articles.edit', $article));

        if ($user->can('hasAdminAccess')) {
            if ($user->can('update', $article)) {
                $response->assertStatus(Response::HTTP_OK);
                $response->assertJson(['id'=> true, 'title' => true, 'intro_text' => true, 'full_text' => true, 'category_id' => true]);
            } else {
                $response->assertStatus(Response::HTTP_FORBIDDEN);
            }
        } else {
            $response->assertStatus(Response::HTTP_FOUND);
            $response->assertRedirect('/');
        }
    }

    /**
     * Проверка доступа на изменение статьи
     *
     * @dataProvider userDataProvider
     * @param User $user
     * @return void
     */
    public function testAccessToUpdateAction(User $user)
    {
        $article = factory(Article::class)->create();
        $this->actingAs($user);
        $response = $this->json('PUT', route('articles.update', $article),
            ['title' => $article->title, 'intro_text' => $article->intro_text, 'category_id' => $article->category_id]
        );

        if ($user->can('hasAdminAccess')) {
            if ($user->can('update', $article)) {
                $response->assertStatus(Response::HTTP_OK);
                $response->assertJson(['status' => 'ok', 'redirect' => route('articles.index')]);
            } else {
                $response->assertStatus(Response::HTTP_FORBIDDEN);
            }
        } else {
            $response->assertStatus(Response::HTTP_FOUND);
            $response->assertRedirect('/');
        }
    }

    /**
     * Проверка доступа на удаление статьи
     *
     * @dataProvider userDataProvider
     * @param User $user
     * @return void
     */
    public function testAccessToDestroyAction(User $user)
    {
        $article = factory(Article::class)->create();
        $this->actingAs($user);
        $response = $this->delete(route('articles.destroy', $article));

        if ($user->can('hasAdminAccess')) {
            if ($user->can('delete', $article)) {
                $response->assertStatus(Response::HTTP_FOUND);
                $response->assertRedirect(route('articles.index'));
            } else {
                $response->assertStatus(Response::HTTP_FORBIDDEN);
            }
        } else {
            $response->assertStatus(Response::HTTP_FOUND);
            $response->assertRedirect('/');
        }
    }

    /**
     * Проверка создания статьи
     *
     * @dataProvider validationDataProvider
     * @param $passed //данные валидны/невалидны
     * @param $validationTarget //объект валидации
     * @param $data //данные
     * @return void
     */
    public function testStoreData(bool $passed, $validationTarget, array $data)
    {
        $user = factory(User::class)->create(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::ADMIN_GROUP)]);
        $this->actingAs($user);
        $this->assertDatabaseMissing('articles', $data);
        $response = $this->json('POST', route('articles.store'), $data);
        if ($passed) {
            $response->assertStatus(Response::HTTP_OK);
            $this->assertDatabaseHas('articles', $data);
            $response->assertJson(['status' => 'ok', 'redirect' => route('articles.index')]);
        } else {
            $this->assertDatabaseMissing('articles', $data);
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY);
            $response->assertJsonValidationErrors($validationTarget);
        }
    }

    /**
     * Проверка удаления статьи
     *
     * @return void
     */
    public function testDestroyData()
    {
        $user = factory(User::class)->create(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::ADMIN_GROUP)]);
        $this->actingAs($user);
        $article = factory(Article::class)->create();
        $response = $this->delete(route('articles.destroy', $article));
        $response->assertStatus(Response::HTTP_FOUND);
        $this->assertDeleted('articles', ['id' => $article->id]);
        $response->assertRedirect(route('articles.index'));

    }


    /**
     * Проверка изменения статьи
     *
     * @dataProvider validationDataProvider
     * @param $passed //данные валидны/невалидны
     * @param $validationTarget //объект валидации
     * @param $data //данные
     * @return void
     */
    public function testUpdateData(bool $passed, $validationTarget, array $data)
    {
        $user = factory(User::class)->create(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::ADMIN_GROUP)]);
        $this->actingAs($user);
        $article = factory(Article::class)->create();
        $response = $this->json('PUT', route('articles.update', $article), $data);
        if ($passed) {
            $response->assertStatus(Response::HTTP_OK);
            $response->assertJson(['status' => 'ok', 'redirect' => route('articles.index')]);
        } else {
            $response->assertStatus(Response::HTTP_UNPROCESSABLE_ENTITY);
            $response->assertJsonValidationErrors($validationTarget);
        }
    }

    /**
     * Формирование тестовых данных для модели Article
     * @return array
     */
    public function validationDataProvider()
    {
        $faker = Factory::create(Factory::DEFAULT_LOCALE);
        return [
            'title_length_error' => [
                'passed' => false,
                'target' => 'title',
                'data' => [
                    'title' => Str::random(256),
                    'intro_text' => $faker->realText(255),
                    'full_text' => $faker->realText(1000),
                    'category_id' => 1,
                ]
            ],
            'title_required_error' => [
                'passed' => false,
                'target' => 'title',
                'data' => [
                    'title' => null,
                    'intro_text' => $faker->realText(255),
                    'full_text' => $faker->realText(1000),
                    'category_id' => 1,
                ]
            ],
            'introtext_required_error' => [
                'passed' => false,
                'target' => 'intro_text',
                'data' => [
                    'title' => $faker->realText(255),
                    'intro_text' => null,
                    'full_text' => $faker->realText(1000),
                    'category_id' => 1,
                ]
            ],
            'category_required_error' => [
                'passed' => false,
                'target' => 'category_id',
                'data' => [
                    'title' => $faker->realText(255),
                    'intro_text' => $faker->realText(255),
                    'full_text' => $faker->realText(1000),
                    'category_id' => null,
                ]
            ],
            'valid_data' => [
                'passed' => true,
                'target' => null,
                'data' => [
                    'title' => $faker->realText(255),
                    'intro_text' => $faker->realText(255),
                    'full_text' => $faker->realText(1000),
                    'category_id' => 1,
                ]
            ]
        ];
    }

    /**
     * Формирование тестовых пользователей
     * @return array
     */
    public function userDataProvider()
    {
        return [
            UserGroup::ADMIN_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::ADMIN_GROUP)])
            ],
            UserGroup::AUTHOR_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::AUTHOR_GROUP)])
            ],
            UserGroup::EDITOR_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::EDITOR_GROUP)])
            ],
            UserGroup::REGISTERED_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::REGISTERED_GROUP)])
            ],
            UserGroup::MODERATOR_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::MODERATOR_GROUP)])
            ],
            UserGroup::BLOCKED_GROUP => [
                factory(User::class)->make(['group_id' => $this->userGroupsService->getGroupIdByName(UserGroup::BLOCKED_GROUP)])
            ],
        ];
    }

}
